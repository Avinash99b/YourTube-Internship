import video from "../Modals/video.js";
import users from "../Modals/Auth.js";
import history from "../Modals/history.js";
import path from "path";
import fs from "fs";

import mime from "mime-types";

import { fileURLToPath } from "url";
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);



export const uploadvideo = async (req, res) => {
    if (req.file === undefined) {
        return res
            .status(404)
            .json({ message: "plz upload a mp4 video file only" });
    } else {
        try {
            const file = new video({
                videotitle: req.body.videotitle,
                filename: req.file.originalname,
                // --- CHANGE THIS LINE ---
                filepath: req.file.filename, // Store just the filename generated by multer
                // ------------------------
                filetype: req.file.mimetype,
                filesize: req.file.size,
                videochanel: req.user.channelname,
                uploader: req.body.uploader,
                description: req.body.description || undefined,
            });

            await file.save();
            return res.status(201).json("file uploaded successfully");
        } catch (error) {
            console.error(" error:", error);
            return res.status(500).json({ message: "Something went wrong" });
        }
    }
};

export const getallvideo = async (req, res) => {
  try {
    const files = await video.find();
    return res.status(200).send(files);
  } catch (error) {
    console.error(" error:", error);
    return res.status(500).json({ message: "Something went wrong" });
  }
};
export const downloadVideo = async (req, res) => {
  try {
    const userId = req.query.userId;
    const videoId = req.params.id;
    if (!userId) return res.status(400).json({ message: "User ID required" });
    const user = await users.findById(userId);
    if (!user) return res.status(404).json({ message: "User not found" });
    const today = new Date();
    today.setHours(0, 0, 0, 0);
    const downloadsToday = user.downloads.filter((d) => {
      const dDate = new Date(d.date);
      dDate.setHours(0, 0, 0, 0);
      return dDate.getTime() === today.getTime();
    });
    if (user.plan === "free" && downloadsToday.length >= 1) {
      return res.status(403).json({
        message:
          "Free users can only download one video per day. Upgrade to premium for unlimited downloads.",
      });
    }
    // Check if video exists
    const vid = await video.findById(videoId);
    if (!vid) return res.status(404).json({ message: "Video not found" });
    // Record download
    user.downloads.push({ videoId });
    if (!user.downloadedVideos.includes(videoId)) {
      user.downloadedVideos.push(videoId);
    }
    await user.save();
    // Serve file with streaming and range support
    const filePath = path.resolve("uploads/"+vid.filepath);
    const stat = fs.statSync(filePath);
    const fileSize = stat.size;
    const range = req.headers.range;
    if (range) {
      const parts = range.replace(/bytes=/, "").split("-");
      const start = parseInt(parts[0], 10);
      const end = parts[1] ? parseInt(parts[1], 10) : fileSize - 1;
      if (start >= fileSize || end >= fileSize) {
        res.status(416).send('Requested range not satisfiable');
        return;
      }
      const chunkSize = end - start + 1;
      const file = fs.createReadStream(filePath, { start, end });
      res.writeHead(206, {
        'Content-Range': `bytes ${start}-${end}/${fileSize}`,
        'Accept-Ranges': 'bytes',
        'Content-Length': chunkSize,
        'Content-Type': 'video/mp4',
        'Content-Disposition': `inline; filename="${vid.filename}"`
      });
      file.pipe(res);
    } else {
      res.writeHead(200, {
        'Content-Length': fileSize,
        'Content-Type': 'video/mp4',
        'Content-Disposition': `inline; filename="${vid.filename}"`
      });
      fs.createReadStream(filePath).pipe(res);
    }
  } catch (error) {
    console.error(error);
    res.status(500).json({ message: "Error downloading video" });
  }
};

export const getDownloadedVideos = async (req, res) => {
  try {
    const userId = req.query.userId;
    if (!userId) return res.status(400).json({ message: "User ID required" });
    const user = await users.findById(userId).populate("downloadedVideos");
    if (!user) return res.status(404).json({ message: "User not found" });
    res.status(200).json({ downloadedVideos: user.downloadedVideos });
  } catch (error) {
    console.error(error);
    res.status(500).json({ message: "Error fetching downloaded videos" });
  }
};

export const getVideoById = async (req, res) => {
  try {
    const { id } = req.params;
    const vid = await video.findById(id);
    if (!vid) {
      return res.status(404).json({ message: "Video not found" });
    }

      //Increase view count in db
      await video.findByIdAndUpdate(id, { $inc: { views: 1 } });
      return res.status(200).json(vid);
  } catch (error) {
    console.error(error);
    return res.status(500).json({ message: "Error fetching video info" });
  }
};

export const getChannelVideos = async (req, res) => {
  try {
    const { channelname } = req.params;
    const videos = await video.find({ videochanel: channelname });
    return res.status(200).json(videos);
  } catch (error) {
    console.error(error);
    return res.status(500).json({ message: "Error fetching channel videos" });
  }
};

export const deleteChannelVideo = async (req, res) => {
  try {
    const { channelname, videoId } = req.params;
    // Only channel owner can delete
    if (!req.user || req.user.channelname !== channelname) {
      return res.status(403).json({ message: "Unauthorized: Only channel owner can delete videos." });
    }
    const vid = await video.findOne({ _id: videoId, videochanel: channelname });
    if (!vid) {
      return res.status(404).json({ message: "Video not found for this channel." });
    }
    // Delete video file from disk
    const filePath = path.resolve("uploads/" + vid.filepath);
    if (fs.existsSync(filePath)) {
      fs.unlinkSync(filePath);
    }
    await video.deleteOne({ _id: videoId });
    // Delete all history related to this video
    await history.deleteMany({ videoid: videoId });
    return res.status(200).json({ message: "Video and related history deleted successfully." });
  } catch (error) {
    console.error(error);
    return res.status(500).json({ message: "Error deleting video" });
  }
};
